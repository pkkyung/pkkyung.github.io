---
layout: single
title: "ìŠ¤íŠ¸ë¼ì„¼ ì•Œê³ ë¦¬ì¦˜"
date: 2020-04-11 
---

## -ìŠ¤íŠ¸ë¼ì„¼ ì•Œê³ ë¦¬ì¦˜(Strassen Alogorihm)ì— ëŒ€í•˜ì—¬-



###   (ë¹„êµ)ì¼ë°˜ì ì¸ í–‰ë ¬ì˜ ê³±(Naive matrix multiplication)

![](http://yimoyimo.tk/images/strassen1.png )

~~~c
for(int i=0; i<size; i++)
{
  for(int j=0; i<size; j++)
  {
    for( int k=0; k<size; k++)
      C[i][j] += A[i][j]*B[k][j];
  }
}
~~~



###  ìŠ¤íŠ¸ë¼ì„¼ ì•Œê³ ë¦¬ì¦˜ (Strassen Algorithm)

- ì‰¬íŠ¸ë¼ì„¼ ì•Œê³ ë¦¬ì¦˜ ì´ë€? ë…ì¼ì˜ ìˆ˜í•™ì ì‰¬íŠ¸ë¼ì„¼ì´ 1969ë…„ì— ë§Œë“  í–‰ë ¬ ê³±ì…ˆ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ê¸°ì¡´ ë¬´ì‹í•œ ë°©ì‹ì— ë¹„í•´ ì‹œê°„ë³µì¡ë„ê°€ ë” ë‚®ì€ O(n^2.81)ì„ ë³´ì—¬ì¤€ë‹¤.
- í–‰ë ¬ CëŠ” í–‰ë ¬ Aì™€ Bì˜ ì—°ì‚°ìœ¼ë¡œ ì´ë£¨ì–´ì§€ë©° í–‰ë ¬ Aì™€ BëŠ” 2n * 2n ì˜ í¬ê¸°ë¥¼ ì§€ë‹Œ ë‹¤. (nì€ ì„ì˜ì˜ ì •ìˆ˜ì´ë‹¤.) ë§Œì•½ 2n * 2nì´ ì•„ë‹ ê²½ìš° ë¹ˆ ìë¦¬ë¥¼ 0ìœ¼ë¡œ ì±„ì›Œ 2n * 2n ê¼´ë¡œ ë§Œë“¤ê³  ì‰¬íŠ¸ë¼ì„¼ í–‰ë ¬ ê³±ì„ ì§„í–‰í•œë‹¤.
- ë”°ë¼ì„œ í–‰ë ¬ A, B, CëŠ” ì„œë¡œ í¬ê¸°ê°€ ê°™ì€ 4ê°œì˜ ë¶€ë¶„ í–‰ë ¬ë¡œ ë¶„í• ì´ ê°€ëŠ¥í•˜ë‹¤.

![](http://yimoyimo.tk/images/strassen2.png)

- A, B í–‰ë ¬ì„ ê°ê°€ 4ê°œì”© ì´ 8ê°œì˜ ë¶€ë¶„í–‰ë ¬ë¡œ ë¶„í• í•œ í›„ ì‰¬íŠ¸ë¼ì„¼ ì•Œê³ ë¦¬ì¦˜ ì—°ì‚°ì„ ìˆ˜í–‰í•œë‹¤. ê¸°ì¡´ì— í–‰ë ¬ê³±ì€ ë‹¨ìˆœíˆ 8ë²ˆì˜ ê³±ì…ˆê³¼ 4ë²ˆì˜ ë§ì…ˆì´ í•„ìš”í–ˆì§€ë§Œ, ì‰¬íŠ¸ë¼ì„¼ì˜ ë°©ë²•ì€ 7ë²ˆì˜ ê³±ì…ˆê³¼ 18ë²ˆì˜ ë§ì…ˆ/ëº„ì…ˆì„ í•„ìš”ë¡œ í•œë‹¤. ì»´í“¨í„°ì˜ ì…ì¥ì—ì„œëŠ” ê³±ì…ˆ ì—°ì‚°ì´ ë§ì…ˆ ëº„ì…ˆ ì—°ì‚°ë³´ë‹¤ ë¶€ë‹´ì´ í¬ë¯€ë¡œ ì‰¬íŠ¸ë¼ì„¼ ì•Œê³ ë¦¬ì¦˜ì´ í›¨ì”¬ ì¢‹ì€ ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.

- ì‰¬íŠ¸ë¼ì„¼ ì•Œê³ ë¦¬ì¦˜ì— ë”°ë¼ ë‹¤ìŒ 7ê°œì˜ ìˆ˜ì‹ìœ¼ë¡œ ê³± Cë¥¼ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.

  

#### ìŠ¤íŠ¸ë¼ì„¼ ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„ ì†ŒìŠ¤ì½”ë“œğŸ‘‡ğŸ‘‡

```java
public class Strassen {

 
       public static void main(String[] args) {
            
             int n = 1024;
            
             int[][] x = initMetrix(n);
             int[][] y = initMetrix(n);
            
             int[][] nomalResult = Strassen.metrixMul(n, x, y);
            
             Strassen strassen = new Strassen();
            
             int[][] strassenReslut = strassen.excuteStrassen(x, y);
            
             boolean checkMetrix = true;
             for (int i = 0; i < n; i++) {
                   
                    for (int j = 0; j < n; j++) {
                          
                           if (nomalResult[i][j] != strassenReslut[i][j]) {
                                 checkMetrix = false;
                           }
                    }
                   
             }
            
            
             System.out.println("ê²°ê³¼ : " + checkMetrix);
            
       }
      
       public static int[][] initMetrix(int n) {
            
             Random r = new Random();
            
             int[][] resultMetrix = new int [n][n];
            
             for (int i = 0; i < n; i++) {
                    for (int j = 0; j < n; j++) {
                           resultMetrix[i][j] = r.nextInt(30);
                    }
             }
             return resultMetrix;
       }
      
      
       public int[][] excuteStrassen(int[][] metrixX, int[][] metrixY) {
            
             // ìŠ¤íŠ¸ë¼ì„¼ì˜ ê²½ìš° n*n í–‰ë ¬ë¡œ ì—°ì‚°
             int n = metrixX.length;
            
             // ì„ê³„ ì°¨ì› ë³´ë‹¤ ì‘ì„ ê²½ìš° ê¸°ì¡´ ë©”íŠ¸ë¦­ìŠ¤ ê³±ìœ¼ë¡œ í’€ì´
             if (n <= 2) {
                    return metrixMul(n, metrixX, metrixY);
             }
            
             // 4 ë“±ë¶„
             int rank = n / 2;
            
             // ë°°ì—´ ë¶„í•´
             int[][] a11 = subMetrix(rank, 0, 0, metrixX);
             int[][] a12 = subMetrix(rank, 0, rank, metrixX);
             int[][] a21 = subMetrix(rank, rank, 0, metrixX);
             int[][] a22 = subMetrix(rank, rank, rank, metrixX);
             int[][] b11 = subMetrix(rank, 0, 0, metrixY);
             int[][] b12 = subMetrix(rank, 0, rank, metrixY);
             int[][] b21 = subMetrix(rank, rank, 0, metrixY);
             int[][] b22 = subMetrix(rank, rank, rank, metrixY);
                          
             int[][] m1 = excuteStrassen(metrixSum(a11, a22), metrixSum(b11, b22)); // m1=(a11+a11)(b11+b22)
             int[][] m2 = excuteStrassen(metrixSum(a21, a22), b11); // m2=(a21+a22)b11
             int[][] m3 = excuteStrassen(a11, metrixSub(b12, b22)); // m3=a11(b12-b22)
             int[][] m4 = excuteStrassen(a22, metrixSub(b21, b11)); // m4=a22(b21-b11)
             int[][] m5 = excuteStrassen(metrixSum(a11, a12), b22); // m5=(a11+a12)b22
             int[][] m6 = excuteStrassen(metrixSub(a21, a11), metrixSum(b11, b12)); // m6=(a21-a11)(b11+b12)
             int[][] m7 = excuteStrassen(metrixSub(a12, a22), metrixSum(b21, b22)); // m7=(a12-a22)(a21+b22)
            
             // ê²°ê³¼ ìƒì„±
             int[][] c11 = metrixSum(metrixSub(metrixSum(m1, m4), m5), m7); // c11 = m1 + m4 - m5 + m7
             int[][] c12 = metrixSum(m3, m5); // c12 = m3 + m5
             int[][] c21 = metrixSum(m2, m4); // c21 = m2 + m4
             int[][] c22 = metrixSum(metrixSub(metrixSum(m1, m3), m2), m6); // c22 = m1 + m3 - m2 + m6
            
             // ê²°í•©
             return combin(c11, c12, c21, c22);
       }
      
       private int[][] combin(int[][] c11, int[][] c12, int[][] c21, int[][] c22) {
             int n = c11.length;
 
             int[][] resultMetrix = new int [n*2][n*2];
            
             for (int i = 0; i < n; i ++) {
                    for (int j = 0; j < n; j++) {
                           resultMetrix[i][j] = c11[i][j]; // 11
                           resultMetrix[i][j + n] = c12[i][j]; // 12
                           resultMetrix[i + n][j] = c21[i][j]; // 21
                           resultMetrix[i + n][j + n] = c22[i][j]; // 22
                    }
             }
             return        resultMetrix;
       }
      
       private int[][] subMetrix(int n, int startX, int startY, int[][] metrix) {
            
             int[][] subMetirx = new int[n][n];
            
             for (int i = 0, x = startX; i < n; i++, x++) {
                    for (int j = 0, y = startY; j < n; j++, y++) {
                           subMetirx[i][j] = metrix[x][y];
                    }
             }
             return subMetirx;
       }
      
       private int[][] metrixSum(int[][] metrixX, int[][] metrixY) {
             int n = metrixX.length;
             int[][] metrixResult = new int[n][n];
            
             for (int i = 0; i < n; i++) {
                    for (int j = 0; j < n; j++) {
                           metrixResult[i][j] = metrixX[i][j] + metrixY[i][j];
                    }
             }
            
             return metrixResult;
       }
      
       private int[][] metrixSub(int[][] metrixX, int[][] metrixY) {
             int n = metrixX.length;
             int[][] metrixResult = new int[n][n];
            
             for (int i = 0; i < n; i++) {
                    for (int j = 0; j < n; j++) {
                           metrixResult[i][j] = metrixX[i][j] - metrixY[i][j];
                    }
             }
             return metrixResult;
       }
      
       public static int[][] metrixMul(int n, int[][] metrixX, int[][] metrixY) {
            
             int [][] result = new int[n][n];
            
             for (int i = 0; i < n; i++) {
                    for (int j = 0; j < n; j++) {
                           for (int k = 0; k < n; k++) {
                                 result[i][j] += metrixX[i][k] * metrixY[k][j];
                           }
                    }
                   
             }
            
             return result;
       }
}

```









